// Generated by ts-to-zod
import {z} from "zod"

export const nodeSchema = z.record(z.unknown()).and(
	z.object({
		id: z.string(),
		position: z.array(z.number()).optional(),
		size: z.array(z.number()).optional(),
		resource: z.string().optional(),
		data: z.array(z.unknown()).optional(),
		rotation: z.number().optional(),
		scale: z.array(z.number()).optional(),
	})
)

export const relationSchema = z.record(z.unknown()).and(
	z.object({
		id: z.string(),
		data: z.array(z.unknown()).optional(),
	})
)

export const schemaSchema = z.record(z.unknown()).and(
	z.object({
		uri: z.string(),
		schema: z.record(z.unknown()).optional(),
		location: z.string().optional(),
		name: z.string().optional(),
	})
)

export const representationSchema = z.record(z.unknown()).and(
	z.object({
		location: z.string().optional(),
		"mime-type": z.string().optional(),
		content: z.string().optional(),
	})
)

export const ocifNodeArrowSchema = z.record(z.unknown()).and(
	z.object({
		strokeWidth: z.number().optional(),
		strokeColor: z.string().optional(),
		fillColor: z.string().optional(),
		start: z.tuple([z.number(), z.number()]).optional(),
		end: z.tuple([z.number(), z.number()]).optional(),
		startMarker: z
			.union([z.literal("none"), z.literal("arrowhead")])
			.optional(),
		endMarker: z
			.union([z.literal("none"), z.literal("arrowhead")])
			.optional(),
		relation: z.string().optional(),
	})
)

export const ocifRelEdgeSchema = z.record(z.unknown()).and(
	z.object({
		start: z.string(),
		end: z.string(),
		directed: z.boolean().optional(),
		rel: z.string().optional(),
		node: z.string().optional(),
	})
)

export const ocifRelGroupSchema = z.record(z.unknown()).and(
	z.object({
		members: z.array(z.string()),
	})
)

export const ocifNodeOvalSchema = z.record(z.unknown()).and(
	z.object({
		strokeWidth: z.number().optional(),
		strokeColor: z.string().optional(),
		fillColor: z.string().optional(),
	})
)

export const ocifNodePathSchema = z.record(z.unknown()).and(
	z.object({
		strokeWidth: z.number().optional(),
		strokeColor: z.string().optional(),
		fillColor: z.string().optional(),
		path: z.string(),
	})
)

export const ocifNodeRectSchema = z.record(z.unknown()).and(
	z.object({
		strokeWidth: z.number().optional(),
		strokeColor: z.string().optional(),
		fillColor: z.string().optional(),
	})
)

export const ocifRelSetSchema = z.record(z.unknown()).and(
	z.object({
		members: z.array(z.string()),
	})
)

export const ocifRelHyperedgeSchema = z.record(z.unknown()).and(
	z.object({
		endpoints: z
			.array(
				z.record(z.unknown()).and(
					z.object({
						id: z.string(),
						direction: z
							.union([
								z.literal("in"),
								z.literal("out"),
								z.literal("undir"),
							])
							.optional(),
						weight: z.number().optional(),
					})
				)
			)
			.optional(),
		weight: z.number().optional(),
		rel: z.string().optional(),
	})
)

export const ocifRelParentChildSchema = z.record(z.unknown()).and(
	z.object({
		parent: z.string().optional(),
		child: z.string().optional(),
		inherit: z.boolean().optional(),
	})
)

export const ocifNodePortsSchema = z.record(z.unknown()).and(
	z.object({
		ports: z.array(z.string()).optional(),
	})
)

export const ocifNodeRelativeSchema = z.record(z.unknown()).and(
	z.object({
		source: z.string(),
		position: z.array(z.number()).optional(),
		rotation: z.number().optional(),
	})
)

export const resourceSchema = z.record(z.unknown()).and(
	z.object({
		id: z.string(),
		representations: z.array(representationSchema),
	})
)

export const oCIFCore04Schema = z.record(z.unknown()).and(
	z.object({
		ocif: z.string(),
		nodes: z.array(nodeSchema).optional(),
		relations: z.array(relationSchema).optional(),
		resources: z.array(resourceSchema).optional(),
		schemas: z.array(schemaSchema).optional(),
	})
)
